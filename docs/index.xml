<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lars&#39; blog</title>
    <link>https://rotgers.io/</link>
    <description>Recent content on Lars&#39; blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 16 Oct 2022 07:47:11 +0100</lastBuildDate><atom:link href="https://rotgers.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>N-body simulation in 2D</title>
      <link>https://rotgers.io/posts/n-body/</link>
      <pubDate>Sun, 16 Oct 2022 07:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/n-body/</guid>
      <description>A few days ago I implemented a n-body simulation in Python, which is used to generate the following animation:
It uses a vectorized form of calculating the acceleration matrix, which is used to update the positions of the bodies. The velocity is integrated with leapfrog integration, which unlike Euler integration, is stable for oscillatory motion. It is pretty efficient. The acceleration matrix is calculated for 2D, but is easily extended to work in 3D as well.</description>
    </item>
    
    <item>
      <title>Ordered fractions</title>
      <link>https://rotgers.io/posts/ordered-fractions/</link>
      <pubDate>Wed, 10 Aug 2022 00:00:00 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/ordered-fractions/</guid>
      <description>In this post we will look at solving Project Euler&amp;rsquo;s problem #71, which is about ordered fractions. I have been puzzling with pen and paper for a while during this problem, and researching about fractions really paid off big time for this problem. The final solution is pretty elegant in my opinion. Let&amp;rsquo;s get into it!
Problem statement#Consider the fraction $n / d$, where $n$ and $d$ are positive integers.</description>
    </item>
    
    <item>
      <title>Counting rectangles</title>
      <link>https://rotgers.io/posts/counting-rectangles/</link>
      <pubDate>Wed, 06 Jul 2022 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/counting-rectangles/</guid>
      <description>In this post we will work out a solution to the Project Euler problem #85 where we have to count rectangles.
Problem statement
By counting carefully it can be seen that a rectangular grid measuring 3 by 2 contains eighteen rectangles. Although there exists no rectangular grid that contains exactly two million rectangles, find the area of the grid with the nearest solution.
Naïve&amp;nbsp;solution
As usual, I always try to define a naïve implementation first, and build from there.</description>
    </item>
    
    <item>
      <title>Path sum: two ways</title>
      <link>https://rotgers.io/posts/path-sum-two-ways/</link>
      <pubDate>Fri, 10 Jun 2022 00:00:00 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/path-sum-two-ways/</guid>
      <description>In this post we will look at solving problem 81 on Project Euler. This problem is about finding a minimal path sum in a matrix. There are three variants of this problem, and this is the easiest one.
Problem statement#In the 5 by 5 matrix below, the minimal path sum from the top left to the bottom right, by only moving to the right and down, is indicated in bold red and is equal to 2427.</description>
    </item>
    
    <item>
      <title>Plotting trees recursively</title>
      <link>https://rotgers.io/posts/plotting-trees-recursively/</link>
      <pubDate>Wed, 18 May 2022 11:42:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/plotting-trees-recursively/</guid>
      <description>The idea for this visualization is something I have been thinking about for quite some time now. Although it is not this specific visualization per se, but the idea of visualizing a nested tree in an appealing way. This method is actually quite easy to implement, and HTML and CSS are doing all the heavy lifting of displaying something that actually looks nice. The illustration below is an example of what the final result will look like, and the rest of this post is about developing the visualization.</description>
    </item>
    
    <item>
      <title>Sqrt(x)</title>
      <link>https://rotgers.io/posts/sqrt-x/</link>
      <pubDate>Thu, 12 May 2022 11:42:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/sqrt-x/</guid>
      <description>I came across a fun exercise on LeetCode, where you have to calculate $f(x) = \sqrt{x}$, without using the standard library functions such as Math.Pow or x**0.5. Wikipedia has plenty of implementations to solve this problem efficiently, but I figured it would be a nice challenge to come up with a solution of my own.
My approach was to determine a upper and a lower bound, and do a binary search to find the solution.</description>
    </item>
    
    <item>
      <title>Gambler&#39;s Fallacy</title>
      <link>https://rotgers.io/posts/gamblers-fallacy/</link>
      <pubDate>Sun, 27 Mar 2022 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/gamblers-fallacy/</guid>
      <description>Suppose we are throwing coins and bet if it is going to be head ($H$) or tails ($T$). After throwing the coin three times, it resulted in heads all of the throws. Do you think that the fourth throw will be heads, or will it be tails?&amp;nbsp;
Most people would assume that it is not likely to throw heads three times in a row, and it is even more unlikely that it would be four times.</description>
    </item>
    
    <item>
      <title>Totient maximum</title>
      <link>https://rotgers.io/posts/totient-maximum/</link>
      <pubDate>Sat, 26 Mar 2022 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/totient-maximum/</guid>
      <description>In this post we will look at solving problem 69 on Project Euler. This problem is about using Euler&amp;rsquo;s totient function to find a given maximum. Without any further introduction, let&amp;rsquo;s dive into it.
Problem statement#Euler&amp;rsquo;s Totient function, $\varphi(n)$, is used to determine the number of numbers less than $n$ which are relatively prime to $n$. For example, as 1, 2, 4, 5, 7, and 8, are all less than nine, and relatively prime to nine, $\varphi(9) = 6$.</description>
    </item>
    
    <item>
      <title>Monopoly odds</title>
      <link>https://rotgers.io/posts/probability-analysis-of-monopoly/</link>
      <pubDate>Sun, 28 Feb 2021 11:42:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/probability-analysis-of-monopoly/</guid>
      <description>Introduction#A few years ago I have written a detailed analysis of the probabilities in Monopoly. However, because of handwaving many rules to make it easier to analyze, I wanted to redo it and use all the rules this time. The main motivation for doing this is to solve a question on Project Euler. While we are at it, I also wanted to take the time to answer a few different questions as well.</description>
    </item>
    
    <item>
      <title>Dungeon generation with Newton&#39;s law of gravity</title>
      <link>https://rotgers.io/posts/dungeon-generation/</link>
      <pubDate>Wed, 03 Feb 2021 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/dungeon-generation/</guid>
      <description>You might wonder what Newton&#39;s law of gravitation has to do with the generation of dungeons, but if we use this concept we can use it to generate a dungeon of rooms. Instead of using something like a BSP algorithm, my idea was to just throw a bunch of rooms on top of each other, and let them push each other away until there are no longer any collisions. The result looks like this.</description>
    </item>
    
    <item>
      <title>Caustics 2D</title>
      <link>https://rotgers.io/posts/caustics_2d/</link>
      <pubDate>Fri, 15 Jan 2021 10:08:00 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/caustics_2d/</guid>
      <description>This is a 2D shader that uses a Monte Carlo method to render the scene. For every pixel, multiple samples are taken to determine the colour of the pixel. Each sample will have a random direction ray. We will then only check if the ray hits a light source, or misses a light source. If a light source is hit, then that lights colour will contribute to the pixel sample.</description>
    </item>
    
    <item>
      <title>Iterated function systems</title>
      <link>https://rotgers.io/posts/ifs/</link>
      <pubDate>Tue, 22 Dec 2020 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/ifs/</guid>
      <description>In this post I will explain a simple iterated function system, also called IFS.We will start of with explaining the basic transformations that we apply, and finally work our way up to get a result like this.I have also included a live demo below that is hosted on ShaderToy.Click play to run the shader. You can change the scaling parameter with the $y$ value of the mouse, and the rotation parameter can be changed with the $x$ value of the mouse.</description>
    </item>
    
    <item>
      <title>Nova fractals</title>
      <link>https://rotgers.io/posts/nova-fractals/</link>
      <pubDate>Sun, 20 Dec 2020 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/nova-fractals/</guid>
      <description>In the previous post we looked at creating Newton fractals. We can generalize the method even further, which is then known as a Nova fractal.The &#34;Mandelbrot&#34; version of the Nova fractal, with $f(z) = z^3 - 1$, and $z=1$.The Nova fractal is created by using Newton&#39;s method, and adding a parameter $c$ to the end:$$z_{n+1} = z - \frac{f(z)}{f&#39;(z)} + c.$$We can get a &#34;</description>
    </item>
    
    <item>
      <title>Newton fractals</title>
      <link>https://rotgers.io/posts/newton-fractals/</link>
      <pubDate>Sun, 20 Dec 2020 07:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/newton-fractals/</guid>
      <description>Another interesting set of fractals, are Newton fractals.Newton fractals are created by applying Newton&#39;s method to complex function $f(z)$. The method uses the iterated equation$$z_{n+1} = z - \frac{f(z)}{f&#39;(z)}.$$If we want to apply Newton&#39;s method, we also need to find the derivative of the function $f(z)$.Since Newton&#39;s method is used to find the zero&#39;s of a function, if we repeatedly apply it to a point $z$, then $f(z_{n\rightarrow\infty}) = 0$.</description>
    </item>
    
    <item>
      <title>Julia set explorer</title>
      <link>https://rotgers.io/posts/julia-set-explorer/</link>
      <pubDate>Sat, 19 Dec 2020 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/julia-set-explorer/</guid>
      <description>A live demo of this shader is available on ShaderToy. You can select a point on the Mandelbrot set to see the corresponding Julia set. If the mouse is not used, the point follows a path along the main cardioid. The selected point is displayed in red.Everyone who starts making fractals, usually starts with rendering the Mandelbrot set. If this is rendered on the CPU, per pixel, it will usually take quite some time to render the image.</description>
    </item>
    
    <item>
      <title>Cracking padded XOR encryption</title>
      <link>https://rotgers.io/posts/cracking-padded-xor-encryption/</link>
      <pubDate>Fri, 27 Nov 2020 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/cracking-padded-xor-encryption/</guid>
      <description>A method for unbreakable encryption, is the one-time pad. To encrypt a message with this method, we need a list of truly random integers with the same length as the message. If we then XOR the ASCII values of the letters in the message, with the list of random integers, the resulting ciphertext is unbreakable.
However, most of the time people use a password to encrypt a message. If for example, the password is $\text{code}$, then the letters are used multiple times to encrypt the message.</description>
    </item>
    
    <item>
      <title>Compartment model for epidemiology</title>
      <link>https://rotgers.io/posts/compartment-model-epidemiology/</link>
      <pubDate>Sat, 14 Mar 2020 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/compartment-model-epidemiology/</guid>
      <description>This post looks at a compartment model for epidemiology and analyzes the different relationships between the variables in the model. Finally, it draws conclusions about the impact the variables have on the model.
SEIRD-model#The population is divided into compartments, with the assumption that every individual has the same characteristics. There are a total of five compartments:
Susceptible ($S$) Exposed ($E$) Infected ($I$) Recovered ($R$) Diseased ($D$) The population flows in the following direction between the compartments.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://rotgers.io/list-repos-cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rotgers.io/list-repos-cpp/</guid>
      <description> OpenGL game engine for learning C++/OpenGL Virtual Machine (CPU emulator) in C++ CTF challenge - Reverse engineering Sudoku solver </description>
    </item>
    
    <item>
      <title></title>
      <link>https://rotgers.io/list-repos-cs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rotgers.io/list-repos-cs/</guid>
      <description> Wave function collapse demo Min-conflict CSP solver for N-Queens (N = 128) Prototype of a CSP solver that solves expressions Solving Sudoku as a CSP with Forward Propagation Physics Light 2D Google Proxy Simple CSP solver Procedural mesh editor in Unity Newtonian Physics in Unity Raytracing Graph Theory Algorithms Flappy Bird VR with Unity 2D Platform game with Unity Computing System with Logical Gates Maze generator with Kruskal&amp;rsquo;s algorithm </description>
    </item>
    
    <item>
      <title></title>
      <link>https://rotgers.io/list-repos-glsl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rotgers.io/list-repos-glsl/</guid>
      <description> Fractal Shaders 2D Fractals </description>
    </item>
    
    <item>
      <title></title>
      <link>https://rotgers.io/list-repos-jsts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rotgers.io/list-repos-jsts/</guid>
      <description> Dungeon generation with Newton&amp;rsquo;s law of gravitation Equirectangular to cubemap projection HTML5 TypeScript Template 3D L-systems Procedural generation 3D engine with Canvas Simple perspective projection Binary search tree algorithm (BST) Convex hull algorithm </description>
    </item>
    
    <item>
      <title></title>
      <link>https://rotgers.io/list-repos-ml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rotgers.io/list-repos-ml/</guid>
      <description> Principle Component Analysis with R Applying PCA on a heart disease dataset with R (dutch) k-Means clustering </description>
    </item>
    
    <item>
      <title></title>
      <link>https://rotgers.io/list-repos-other/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rotgers.io/list-repos-other/</guid>
      <description> Age of Empires II - AI Blender 8K Fractals Sudoku solver in Delphi </description>
    </item>
    
    <item>
      <title></title>
      <link>https://rotgers.io/list-repos-python/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rotgers.io/list-repos-python/</guid>
      <description> Project Euler Problem Solving Library Funny graph theory problem Image to polygon Calcupy CSP solver Gradient descent Probability Analysis of Monopoly (Approximated) Probability Analysis of Monopoly (Analytical) Modeling endemic diseases with ODE&amp;rsquo;s Strategy Backtesting for Algorithmic Trading Technical Analysis library for Algorithmic Trading </description>
    </item>
    
  </channel>
</rss>
