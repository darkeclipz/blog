<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Lars&#39; blog</title>
    <link>https://rotgers.io/posts/</link>
    <description>Recent content in Posts on Lars&#39; blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 11 Dec 2022 10:08:00 +0100</lastBuildDate><atom:link href="https://rotgers.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>28 Tauri Aa</title>
      <link>https://rotgers.io/posts/28-tauri-aa/</link>
      <pubDate>Sun, 11 Dec 2022 10:08:00 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/28-tauri-aa/</guid>
      <description>The idea of this shader is to visualize a star and the gravity field that is generated by it. A few key aspects of the shader:
It uses raymarching to render the scene by taking four samples per pixel. The coordinates of the point on the sphere are mapped to UV-coordinates which are used for the texture. The closest distance to the sphere is also being tracked by the raymarcher, which is used to add the glow.</description>
    </item>
    
    <item>
      <title>Primer on constraint satisfaction problems</title>
      <link>https://rotgers.io/posts/csp-primer/</link>
      <pubDate>Wed, 07 Dec 2022 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/csp-primer/</guid>
      <description>A lot of problems can be described as a constraint satisfaction problem (CSP). This post is intended as a short primer to help you get started.
What is a constraint satisfaction problem?#A constraint satisfaction problem consists of three components. The first component is a variable to which a value can be assigned. The second component is the domain. Each variable has a list of possible values that can be assigned to the variable.</description>
    </item>
    
    <item>
      <title>Projectile motion (part I)</title>
      <link>https://rotgers.io/posts/projectile-motion/</link>
      <pubDate>Sat, 19 Nov 2022 10:08:00 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/projectile-motion/</guid>
      <description>In this post we will be looking at the motion of projectiles. Starting from first principles by deriving the equations governing projectile motion. In a later post we will be studying how the different quantities are related.
Deriving the equations#A projectile is an object which is moving over time because of its velocity and acceleration. As we know from physics, components that are perpendicular behave independently. In our 2D case this means that the horizontal and vertical components of motion are independent of each other.</description>
    </item>
    
    <item>
      <title>Ray-sphere intersection</title>
      <link>https://rotgers.io/posts/ray-sphere-intersection/</link>
      <pubDate>Thu, 10 Nov 2022 10:08:00 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/ray-sphere-intersection/</guid>
      <description>One of the first things you will stumble across when writing a raytracer is to find out where a ray and a sphere intersect. In this post we will derive a method that finds this point from first principles.
Vector-form definition of a sphere#A sphere is mathematically defined, in vector-form, as
$$ ||\ \mathbf{x} - \mathbf{c}\ ||^2 = r^2, $$
where $\mathbf{x}$ is the point on the sphere, $\mathbf{c}$ is the center of the sphere, and $r^2$ is the radius of the sphere.</description>
    </item>
    
    <item>
      <title>Bifurcation diagram of the logistics map in the Mandelbrot set</title>
      <link>https://rotgers.io/posts/mandelbrot-bifurcation/</link>
      <pubDate>Sun, 06 Nov 2022 18:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/mandelbrot-bifurcation/</guid>
      <description>This is one of those thing that absolutely blew my mind when I found about it. The first the I came across this is in a video about the logistics map by Veritasium.I suggest to check out the video if you want to know more about it.The scene below renders the Mandelbrot set and uses all the real values of $z$ that are in the set as the y-axis.</description>
    </item>
    
    <item>
      <title>Sin(z) fractals</title>
      <link>https://rotgers.io/posts/sinz_fractal/</link>
      <pubDate>Sun, 06 Nov 2022 10:42:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/sinz_fractal/</guid>
      <description>Another interesting set of fractals is produced by looking at the Julia set of the iterated function
$$ z_{n+1} = \sin (z_n) \cdot c. $$
Instead of looking at the magnitude of the complex number to determine if the orbit escapes to infinity, only the imaginary part of $z$ is used in this case. If the imaginary part of $z$ is greater than 50, then it is decided that the orbit escapes to infinity.</description>
    </item>
    
    <item>
      <title>Mandelbrot with Rust</title>
      <link>https://rotgers.io/posts/mandelbrot-rust/</link>
      <pubDate>Sun, 23 Oct 2022 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/mandelbrot-rust/</guid>
      <description>This write-up will explain how an image of the Mandelbrot set can be created with Rust. The image that the program generates is displayed below. It uses a smooth iteration counter that is used to get a smooth coloring. This is one of the first programs that I have written in Rust, and I have kept it pretty simple, meaning that it does not feature multi-threaded support.
Importing the image crate#To generate images in Rust we can use the image crate.</description>
    </item>
    
    <item>
      <title>2-body potential energy function</title>
      <link>https://rotgers.io/posts/2-body-potential-energy/</link>
      <pubDate>Sun, 16 Oct 2022 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/2-body-potential-energy/</guid>
      <description>Suppose that we have the sun-earth system. The potential energy of a satellite (any point $(x, y)$ in the system) is determined by the following equation:
$$ u = -\frac{1-\mu}{\sqrt{(x + \mu)^2 + y^2}} - \frac{\mu}{\sqrt{[x - (1 - \mu)]^2 + y^2}} - \frac{1}{2}(x^2 + y^2), $$
where $\mu$ is the distance from the center of rotation (the barycenter).
If we use the equation to create a contour plot, we get a pretty cool visualization of the potential energy in the sun-earth system.</description>
    </item>
    
    <item>
      <title>N-body simulation in 2D</title>
      <link>https://rotgers.io/posts/n-body/</link>
      <pubDate>Sun, 16 Oct 2022 07:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/n-body/</guid>
      <description>A few days ago I implemented a n-body simulation in Python, which is used to generate the following animation:
Vectorized n-body implementation#It uses a vectorized form of calculating the acceleration matrix, which is used to update the positions of the bodies. The velocity is integrated with leapfrog integration, which unlike Euler integration, is stable for oscillatory motion. It is pretty efficient. The acceleration matrix is calculated for 2D, but is easily extended to work in 3D as well.</description>
    </item>
    
    <item>
      <title>Ordered fractions</title>
      <link>https://rotgers.io/posts/ordered-fractions/</link>
      <pubDate>Wed, 10 Aug 2022 00:00:00 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/ordered-fractions/</guid>
      <description>In this post we will look at solving Project Euler&amp;rsquo;s problem #71, which is about ordered fractions. I have been puzzling with pen and paper for a while during this problem, and researching about fractions really paid off big time for this problem. The final solution is pretty elegant in my opinion. Let&amp;rsquo;s get into it!
Problem statement#Consider the fraction $n / d$, where $n$ and $d$ are positive integers.</description>
    </item>
    
    <item>
      <title>Counting rectangles</title>
      <link>https://rotgers.io/posts/counting-rectangles/</link>
      <pubDate>Wed, 06 Jul 2022 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/counting-rectangles/</guid>
      <description>In this post we will work out a solution to the Project Euler problem #85 where we have to count rectangles.
Problem statement
By counting carefully it can be seen that a rectangular grid measuring 3 by 2 contains eighteen rectangles. Although there exists no rectangular grid that contains exactly two million rectangles, find the area of the grid with the nearest solution.
Naïve&amp;nbsp;solution
As usual, I always try to define a naïve implementation first, and build from there.</description>
    </item>
    
    <item>
      <title>Path sum: two ways</title>
      <link>https://rotgers.io/posts/path-sum-two-ways/</link>
      <pubDate>Fri, 10 Jun 2022 00:00:00 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/path-sum-two-ways/</guid>
      <description>In this post we will look at solving problem 81 on Project Euler. This problem is about finding a minimal path sum in a matrix. There are three variants of this problem, and this is the easiest one.
Problem statement#In the 5 by 5 matrix below, the minimal path sum from the top left to the bottom right, by only moving to the right and down, is indicated in bold red and is equal to 2427.</description>
    </item>
    
    <item>
      <title>Plotting trees recursively</title>
      <link>https://rotgers.io/posts/plotting-trees-recursively/</link>
      <pubDate>Wed, 18 May 2022 11:42:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/plotting-trees-recursively/</guid>
      <description>The idea for this visualization is something I have been thinking about for quite some time now. Although it is not this specific visualization per se, but the idea of visualizing a nested tree in an appealing way. This method is actually quite easy to implement, and HTML and CSS are doing all the heavy lifting of displaying something that actually looks nice. The illustration below is an example of what the final result will look like, and the rest of this post is about developing the visualization.</description>
    </item>
    
    <item>
      <title>Sqrt(x)</title>
      <link>https://rotgers.io/posts/sqrt-x/</link>
      <pubDate>Thu, 12 May 2022 11:42:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/sqrt-x/</guid>
      <description>I came across a fun exercise on LeetCode, where you have to calculate $f(x) = \sqrt{x}$, without using the standard library functions. Wikipedia has plenty of implementations to solve this problem efficiently, but I figured it would be a fun excercise to come up with a solution of my own.Binary search algorithmMy approach was to determine an upper and a lower bound, and do a binary search to find the solution.</description>
    </item>
    
    <item>
      <title>Gambler&#39;s Fallacy</title>
      <link>https://rotgers.io/posts/gamblers-fallacy/</link>
      <pubDate>Sun, 27 Mar 2022 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/gamblers-fallacy/</guid>
      <description>Suppose we are throwing coins and bet if it is going to be head ($H$) or tails ($T$). After throwing the coin three times, it resulted in heads all of the throws. Do you think that the fourth throw will be heads, or will it be tails?&amp;nbsp;
Most people would assume that it is not likely to throw heads three times in a row, and it is even more unlikely that it would be four times.</description>
    </item>
    
    <item>
      <title>Totient maximum</title>
      <link>https://rotgers.io/posts/totient-maximum/</link>
      <pubDate>Sat, 26 Mar 2022 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/totient-maximum/</guid>
      <description>In this post we will look at solving problem 69 on Project Euler. This problem is about using Euler&amp;rsquo;s totient function to find a given maximum. Without any further introduction, let&amp;rsquo;s dive into it.
Problem statement#Euler&amp;rsquo;s Totient function, $\varphi(n)$, is used to determine the number of numbers less than $n$ which are relatively prime to $n$. For example, as 1, 2, 4, 5, 7, and 8, are all less than nine, and relatively prime to nine, $\varphi(9) = 6$.</description>
    </item>
    
    <item>
      <title>Monopoly odds</title>
      <link>https://rotgers.io/posts/probability-analysis-of-monopoly/</link>
      <pubDate>Sun, 28 Feb 2021 11:42:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/probability-analysis-of-monopoly/</guid>
      <description>Introduction#A few years ago I have written a detailed analysis of the probabilities in Monopoly. However, because of handwaving many rules to make it easier to analyze, I wanted to redo it and use all the rules this time. The main motivation for doing this is to solve a question on Project Euler. While we are at it, I also wanted to take the time to answer a few different questions as well.</description>
    </item>
    
    <item>
      <title>Dungeon generation with Newton&#39;s law of gravity</title>
      <link>https://rotgers.io/posts/dungeon-generation/</link>
      <pubDate>Wed, 03 Feb 2021 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/dungeon-generation/</guid>
      <description>You might wonder what Newton&#39;s law of gravitation has to do with the generation of dungeons, but if we use this concept we can use it to generate a dungeon of rooms. Instead of using something like a BSP algorithm, my idea was to just throw a bunch of rooms on top of each other, and let them push each other away until there are no longer any collisions. The result looks like this.</description>
    </item>
    
    <item>
      <title>Caustics 2D</title>
      <link>https://rotgers.io/posts/caustics_2d/</link>
      <pubDate>Fri, 15 Jan 2021 10:08:00 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/caustics_2d/</guid>
      <description>This is a 2D shader that uses a Monte Carlo method to render the scene. For every pixel, multiple samples are taken to determine the colour of the pixel. Each sample will have a random direction ray. We will then only check if the ray hits a light source, or misses a light source. If a light source is hit, then that lights colour will contribute to the pixel sample.</description>
    </item>
    
    <item>
      <title>Iterated function systems</title>
      <link>https://rotgers.io/posts/ifs/</link>
      <pubDate>Tue, 22 Dec 2020 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/ifs/</guid>
      <description>In this post I will explain a simple iterated function system, also called IFS.We will start of with explaining the basic transformations that we apply, and finally work our way up to get a result like this.I have also included a live demo below that is hosted on ShaderToy.Click play to run the shader. You can change the scaling parameter with the $y$ value of the mouse, and the rotation parameter can be changed with the $x$ value of the mouse.</description>
    </item>
    
    <item>
      <title>Nova fractals</title>
      <link>https://rotgers.io/posts/nova-fractals/</link>
      <pubDate>Sun, 20 Dec 2020 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/nova-fractals/</guid>
      <description>In the previous post we looked at creating Newton fractals at arrived at the generalized Newton&amp;rsquo;s method.
The method can be generalized even further, which is then known as a Nova fractal.
Mandelbrot version of the Nova fractal, with $f(z) = z^3 - 1$, and $z=1$.The Nova fractal is created by using Newton&amp;rsquo;s method, and adding a parameter $c$ to the end:
$$ z_{n+1} = z - \frac{f(z)}{f&amp;rsquo;(z)} + c.</description>
    </item>
    
    <item>
      <title>Newton fractals</title>
      <link>https://rotgers.io/posts/newton-fractals/</link>
      <pubDate>Sun, 20 Dec 2020 07:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/newton-fractals/</guid>
      <description>Another interesting set of fractals, are Newton fractals.Newton fractals are created by applying Newton&#39;s method to complex function $f(z)$. The method uses the iterated equation$$z_{n+1} = z - \frac{f(z_n)}{f&#39;(z_n)}.$$If we want to apply Newton&#39;s method, we also need to find the derivative of the function $f(z)$.Since Newton&#39;s method is used to find the zero&#39;s of a function, if we repeatedly apply it to a point $z$, then $f(z_{n\rightarrow\infty}) = 0$, meaning that every point converges to a root of the complex function.</description>
    </item>
    
    <item>
      <title>Julia set explorer</title>
      <link>https://rotgers.io/posts/julia-set-explorer/</link>
      <pubDate>Sat, 19 Dec 2020 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/julia-set-explorer/</guid>
      <description>A live demo of this shader is available on ShaderToy. You can select a point on the Mandelbrot set to see the corresponding Julia set. If the mouse is not used, the point follows a path along the main cardioid. The selected point is displayed in red.Everyone who starts making fractals, usually starts with rendering the Mandelbrot set. If this is rendered on the CPU, per pixel, it will usually take quite some time to render the image.</description>
    </item>
    
    <item>
      <title>Cracking padded XOR encryption</title>
      <link>https://rotgers.io/posts/cracking-padded-xor-encryption/</link>
      <pubDate>Fri, 27 Nov 2020 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/cracking-padded-xor-encryption/</guid>
      <description>A method for unbreakable encryption, is the one-time pad. To encrypt a message with this method, we need a list of truly random integers with the same length as the message. If we then XOR the ASCII values of the letters in the message, with the list of random integers, the resulting ciphertext is unbreakable.
However, most of the time people use a password to encrypt a message. If for example, the password is $\text{code}$, then the letters are used multiple times to encrypt the message.</description>
    </item>
    
    <item>
      <title>Compartment model for epidemiology</title>
      <link>https://rotgers.io/posts/compartment-model-epidemiology/</link>
      <pubDate>Sat, 14 Mar 2020 08:47:11 +0100</pubDate>
      
      <guid>https://rotgers.io/posts/compartment-model-epidemiology/</guid>
      <description>This post looks at a compartment model for epidemiology and analyzes the different relationships between the variables in the model. Finally, it draws conclusions about the impact the variables have on the model.
SEIRD-model#The population is divided into compartments, with the assumption that every individual has the same characteristics. There are a total of five compartments:
Susceptible ($S$) Exposed ($E$) Infected ($I$) Recovered ($R$) Diseased ($D$) The population flows in the following direction between the compartments.</description>
    </item>
    
  </channel>
</rss>
