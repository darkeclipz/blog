---
title: "Caustics 2D"
date: 2021-01-15T10:08:00+01:00
draft: false
---

<div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-U1w0lMBqW_U/YAH-cxDb0NI/AAAAAAAAExU/oPkOz2pOTDYl5OTF8Pl4Hf88H3r23doWQCLcBGAsYHQ/s1920/2D_Caustics.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="1080" data-original-width="1920" height="360" src="https://1.bp.blogspot.com/-U1w0lMBqW_U/YAH-cxDb0NI/AAAAAAAAExU/oPkOz2pOTDYl5OTF8Pl4Hf88H3r23doWQCLcBGAsYHQ/w640-h360/2D_Caustics.png" width="640" /></a></div><p>This is a 2D shader that uses a Monte Carlo method to render the scene. For every pixel, multiple samples are taken to determine the colour of the pixel. Each sample will have a random direction ray. We will then only check if the ray hits a light source, or misses a light source. If a light source is hit, then that lights colour will contribute to the pixel sample. However, if the ray hits an object, then we will reflect the ray, and march the reflected ray through the scene. The number of times that we reflect the ray when an object is hit, is called the number of bounces.&nbsp;</p><p>Having explained the basic principle behind the rendering technique, the algorithm that follows from it is quite straightforward:</p><p></p><ol style="text-align: left;"><li>For each pixel position $O$.</li><li>Generate a random normalized direction vector $D$. This can be done by selecting a random variable $\underline{x} \sim \textrm{uniform}(0, 1)$, which is then used to create the vector $D = [\cos(2\pi\cdot\underline{x}), \sin(2\pi\cdot\underline{x})]$. Because this point is on the unit circle, it is already normalized.</li><li>Shoot the ray $O + t\cdot D$ into the scene, and determine if an object is hit.</li><li>If the object that is hit is a light source, add the contribution of the light source to the pixel result, and go to the next sample.</li><li>If the object that is hit is not a light source, calculate the reflection ray, and use this ray in step 3. If the number of bounces exceeds a certain threshold, then the result of the pixel is zero.</li></ol><p>This implementation uses two reflection ray bounces to determine if a light source is hit. If we never hit a light source we will return an ambient colour, instead of black.</p><div>The algorithm also uses an anti-aliasing technique which is called a <a href="https://en.wikipedia.org/wiki/Supersampling" rel="nofollow" target="_blank">jitter algorithm</a>, or also <a href="https://en.wikipedia.org/wiki/Stratified_sampling" rel="nofollow" target="_blank">stratified sampling</a>. The image below should illustrate how the samples are generated based on this algorithm.</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bf/Supersampling_-_Jittering.svg/420px-Supersampling_-_Jittering.svg.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="420" data-original-width="420" height="200" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bf/Supersampling_-_Jittering.svg/420px-Supersampling_-_Jittering.svg.png" width="200" /></a></div><br /><div style="text-align: center;">Image from Wikipedia</div><div><br /></div><div>First, the pixel is divided into smaller sub-pixels, and a random point is selected within these sub-pixels. Secondly, multiple samples are created that are sent into the scene to determine if a light source is hit. The stratification is also applied in the generation of the direction vector. The stratification ensures that we do not randomly generate a clump of pixels, or a set of almost equal direction rays. This method will help the image to converge faster.</div><div><br /></div><div>The entire <a href="https://www.shadertoy.com/view/wtKczm" target="_blank">shader is hosted on ShaderToy</a>, and I have also included a live version below:</div><div><br /></div><div><b>Version A: Buffered result, denoised</b></div><div>Use the left mouse button to move the light source(s). If the button is pressed, the image will denoise a bit quicker, so that it feels more responsive. However, the trade-off is a little bit more noise.</div><p></p>

<div style="text-align: center;"><iframe allowfullscreen="" frameborder="0" height="360" src="https://www.shadertoy.com/embed/wtKczm?gui=true&amp;t=10&amp;paused=true&amp;muted=false" width="640"></iframe></div>
<div><br /></div><div>To combine the current frame and the buffered frames, the following formula is used: $$\textrm{color}_\textrm{out} = \alpha \cdot \textrm{buffer} + (1-\alpha)\cdot\textrm{rgb}$$ where $\alpha = 0.995$. Using this method, the image slowly decays to the value of $\textrm{rgb}$, and the noise is barely visible.</div><div><b><br /></b></div><div>
  
<b>Version B: animated light source, increased noise</b></div><div>A lot of noise can be seen in this image. I could add more samples per pixels, or more light samples, but the shader is already heavy as it is.</div><div><b><br /></b></div>

<div style="text-align: center;"><iframe allowfullscreen="" frameborder="0" height="360" src="https://www.shadertoy.com/embed/ttVyzw?gui=true&amp;t=10&amp;paused=true&amp;muted=false" width="640"></iframe></div>
